\chapter{绪论}
\section{研究背景}
\label{sec:background}

软件维护（Software Maintenance）是软件开发周期中耗时最长、开销最大的过程\cite{lehnert2011review}。随着外部环境和用户需求的不断变化，软件系统需要随之进行适应和调整，并修复在实际运行中暴露出来的问题。

软件演进是一类维护过程中常见的活动\cite{pigoski1996practical}。在演进过程中，软件系统可能会由于各种不同的原因发生更新行为。为了实现该过程，现代软件工程提出了许多解决方案，而补丁（Patch）就是其中一类可用于完成程序漏洞修复、软件功能增强、程序性能改善等任务的方案。补丁一般是Diff工具产生的文本数据\cite{hunt1976algorithm}，用于表示以行为单位的程序间文本差异性。它在工业界中得到了广泛应用，是软件维护过程的重要组成部分\cite{le2014patch}。

然而，在实际应用中补丁程序仍具有一定的局限性。由于补丁一般只针对软件的某个专门版本开发，对软件演进过程中不断推出的新版本而言，无法确定补丁程序是否同样适用。再加上补丁程序一般都具有特定的应用目的，例如功能升级、漏洞修补等，使得新版本可能仍然需要应用原有补丁来完善自身，因此在实际的软件维护过程中工程师往往不得不重新开发针对该新版本的特定补丁程序，对人力和时间等资源造成了许多浪费。

可以考虑这样一个应用场景：
\begin{itemize}
	\item 某项目团队在开发过程中使用了某开源第三方软件，并针对该开源软件开发了专门的补丁以适用于本项目。
	\item 当第三方软件更新到新版本，如果集成该新版本，原有的补丁是否还适用？
\end{itemize}

关键在于，补丁是否能够在不同的软件版本之间进行共享，即如何确定补丁对于其他软件版本的兼容性。究其缘由，补丁兼容性问题主要在于补丁程序会引入软件变更（Software Change）\cite{buckley2005towards}，应用这些变更可以实现功能修复、版本升级等目的。然而，软件变更的影响不仅仅局限于被修改的某行，由于软件代码的耦合性，单行变更就足以将其影响传播到软件系统的其他部分\cite{wilkerson2012software,tao2012software}。因此，软件变更不仅会使软件系统发生语法结构上的变化，还会进一步引入语义上的变化。例如，对赋值语句的修改可能会影响到在其后引用该变量的条件语句。

由此可见，如何确定补丁程序对于其他软件版本的兼容性是一个较复杂的问题。根据上文的叙述可知，该问题是由于补丁程序所引入的软件变更和版本升级所引入的软件变更可能发生冲突而造成的，因此该问题的核心在于如何找到变更间的冲突，这种冲突既可能是语法结构上的，也可能是语义行为上的。

对于语法冲突而言，这主要是由于应用过程中变更破坏了代码的语法结构。这种语法结构上的错误可能是多种多样的，例如补丁所要修改的代码不在原位置或已被删除、补丁所要添加的代码已经在该文件中存在等等。对于语义冲突而言，这主要是由于变更对于某行修改可能会影响到代码中的其他语法结构，从而导致程序的行为发生变化，而这种语义变化是不易察觉的。

%因此，我们需要保证补丁造成的语义变化不会影响到版本演进时所引入的语义变化。即我们需要对多次变更间是否存在语义冲突进行检测。

综上所述，语法冲突好发现、易解决，现代的版本控制系统等工具都能够检测并修复之。而语义冲突的检测较为复杂，目前学术界尚无这方面的相关工作。因此，本文将主要考虑对软件变更间的语义冲突进行检测。更详细的问题讨论可以参考章节\ref {sec_problem}。

\section{研究内容}

%如前所述，软件系统总是处在不断演进的过程中。补丁(Patch)是一种常见的软件系统版本演进的实现方法，常用于漏洞和缺陷修复、性能改进、功能升级等。在实际应用中，补丁往往针对某个特定版本的代码而设计，然而现代软件系统往往更新换代较快，因而面临着将补丁应用于其他版本的代码时可能失效的问题。
%
%%为此，我们考虑这样一个问题，针对某软件系统s，假设已有版本$v_1$和$v_2$，其中补丁$p_1$是针对版本$v_1$而设计，应用后能使其演进到版本$v_3$，问$p_1$是否能够成功应用于版本$v_{2}$，并保证不会发生冲突？
%
%因此，考虑到上文中所提出的应用场景，

%如前所述，本文研究在软件演进背景下，补丁对于其他版本代码的兼容性问题。该问题的主要难点在于如何检测补丁应用在其他版本的代码时是否发生冲突。

%为了解决这个问题，我们需要知道：
%\begin{itemize}
%	\item 如何将一个专为某个版本设计的补丁$p$成功应用于版本$v_2$上。
%	\item 检测补丁在应用于新版本之后是否会与该版本代码产生冲突。
%\end{itemize}

%对于第一点来说，这意味着我们需要找到一种方法去消除补丁应用时所引入的语法错误，本文中采用版本合并的方法来做到这一点。
%
%对于第二点来说，考虑到程序代码结构之间的语法冲突已经在第一点中得到妥善解决，那么接下来只需要解决语义冲突即可。

%如前所述，实际上冲突是由于补丁引入的变更所导致的，在其他版本的代码上应用补丁时，它可能会引入语法结构上的错误，也可能会引发语义上的错误。语法结构上的冲突是容易解决的，语义层面的冲突则很难直接被发现。

为了找到补丁与新版本代码间的语义冲突，本文提出了一种基于影响域分析的软件补丁兼容性检测方法，该方法可以找到软件代码在不同版本间引入的变更，并根据这些变更去找到受其语义影响的其他程序代码结构集合，也就是所谓的语义影响域。

在找到这些变更的语义影响域（下文简称“变更影响域”）之后，就可以进行冲突检测。通过分析这些变更影响域之间是否存在重叠，就能够发现补丁对旧版本造成的语义变化是否会影响到旧版本在演进时所引入的语义变化，也就是说，代码在重叠的位置可能存在着冲突。目前而言，冲突的确定需要进一步的人工分析来完成。

在软件补丁兼容性检测问题上，本文的主要贡献包括以下几个部分。

首先，本文对软件补丁兼容性检测问题进行了分析。补丁的兼容性问题主要在于补丁的变更所造成的语义影响之间存在冲突，如何找到这样的语义冲突是解决该问题的重点。

其次，为了找到这样的语义冲突，本文提出了一套补丁兼容性检测方法，该方法能够分析软件版本间的变更，并找到其变更影响域，通过判断变更影响域间是否存在重叠，就能够找到可能存在语义冲突的代码位置。该套检测方法主要包括：
	\begin{itemize}
%		\item 补丁应用：将转为某个版本代码而设计的补丁应用于其他版本代码。
		\item 软件变更影响域分析：该分析过程通过寻找不同软件版本间的变更集合来分析并找到软件变更对代码的语义影响域，即变更影响域。
		\item 软件变更冲突检测：该分析过程根据得到的不同变更影响域，分析其是否存在语义冲突。
	\end{itemize}
	
最后，本文根据该检测方法给出了具体的工具实现，并在工业界的实际项目上进行了实验。根据兼容性检测工具在Eclipse JDT Core项目上的实验结果，本文中所给出的兼容性检测工具是可用的，其检测结果是正确的。
%\begin{enumerate}
%	\item 对软件补丁兼容性检测问题进行了分析。我们发现，补丁的兼容性问题主要在于补丁的变更所造成的语义影响之间存在冲突。
%	\item 提出解决该问题的一套解决方案，包括：
%	\begin{itemize}
%%		\item 补丁应用：将转为某个版本代码而设计的补丁应用于其他版本代码。
%		\item 软件变更影响域分析：分析并获取软件变更对代码的语义影响域。
%		\item 软件变更冲突检测：根据得到的变更的语义影响域，分析其是否存在语义冲突。
%	\end{itemize}
%	\item 根据解决方案给出了具体的工具实现，并在工业界的实际项目上进行了实验。根据兼容性检测工具在Eclipse JDT Core项目上的实验结果，本文中所给出的兼容性检测工具是可用的，其检测结果是正确的。
%\end{enumerate}



%\begin{enumerate}
%	\item 补丁应用。
%	\item 语义影响域分析。
%	\item 补丁冲突分析。		
%\end{enumerate}

%可以具体定义如下，其中structure意为程序语法结构，可以采用不同级别的程序语法结构（如statement、basic block等）进行分析，来获得不同粒度的影响范围：
%	\begin{enumerate}
%		\item
%		change(s) = { structure | structure属于p，并且structure 发生了变更}，该集合可以采用程序间差异分析获得。
%		
%		\item
%		impact(s) = {structure| structure属于p，并且structure 受到change(s)的影响}，该集合可以采用变更影响分析获得。
%		
%	\end{enumerate}
%最后得到的impact(s)即为我们所需的变更的语义影响范围。

%所谓的补丁版本迁移工作是指，由于补丁$p_1$本来是适用于程序版本$v_1$的，如果想要适用于程序$v_2$，可能需要进行一定的版本迁移工作。该部分工作可以从语法层面给出兼容性的答案，并为了实现补丁兼容性而进行一定的语法结构修正，主要使用版本控制系统和文本合并工具完成。
%
%所谓的语义域分析工作是指主要采用程序间差异分析、变更影响分析等手段来对界定补丁$p_i$对程序$v_i$所造成的语义影响。在有了补丁$p_1$和$p_2$的语义影响域后，我们对其进行重叠判断，即可找到冲突。该语义影响域分析（Semantic Impacted Area Analysis）过程可以参考章节\ref {sia}中的详细叙述。
%
%而在有了语义影响范围之后，就可以进行冲突分析的工作。通过影响域的重叠判定，我们可以获得两个补丁间的冲突，通过人工分析的辅助，我们可以判定该互斥子集是否存在误报（false positive），并筛选出真正的互斥子集。
%
%我们可以简单的认定如果两个补丁间如果存在真互斥子集，那么他们之间就存在冲突。而实际上，真互斥子集中的一些互斥变更，根据我们的定义他们是互斥的，但在实际应用中他们其实仍然可能是互相兼容的。
%
%如果对真互斥子集进行人工的冲突分析，可以将这些情况进一步剔除。
%
%可见，我们给出的冲突定义是比实际冲突更加严格的定义，可能会造成一定的过高估计（over-estimate）。在第\ref {exp}章的实验中我们会给出具体的介绍。


\section{本文组织结构}

本文共七章。第一章是绪论，介绍本文的研究背景和主要工作；第二章主要介绍与本文所述内容相关的国内外的工作；第三章主要介绍补丁兼容性检测所要解决的问题、检测方法及其工具实现；第四章主要介绍了检测方法中的软件变更影响域分析方法及其对应的工具模块实现；第五章介绍了检测方法中的软件变更冲突检测过程及其对应的工具模块实现；第六章介绍了实验过程和结果；第七章主要对本文的工作进行了总结，并提出了进一步的工作方向。

%\section{本章小结}
%本章中主要提出了如何进行软件补丁兼容性检测的问题，并介绍了其实际意义。其次介绍了本文中为了解决该问题而做出的主要工作，最后给出了本文的组织结构。

