\chapter{绪论}
\section{研究背景和意义}

软件维护（Software Maintenance）是软件开发周期中耗时最长、开销最大的过程。随着外部环境和用户需求的不断变化，软件系统需要随之进行适应和调整，同时也需要修复在实际运行中暴露出来的问题。

在软件演进的过程中，软件系统可能会由于各种各样的原因而发生更新行为，这是软件维护周期中的常见活动。为了进行软件

补丁（Patch）就是这样一类可以用于完成修补程序漏洞、增强软件功能、改善程序性能等任务的程序。补丁在工业界中得到了广泛的实际应用，是软件维护过程的重要组成部分。

补丁一般是通过Diff工具而产生的文本数据，用于表示以行为单位的程序间差异性。一般而言，Diff工具属于程序差别分析工具中的一种，单纯进行文本的差异性比较，并给出行级别的差异性信息。然而这样产生出来的差异性信息（Patch），只包含了文本差异，而失去了语法、语义等差异信息。

虽然得到了广泛应用，但补丁程序仍然具有一定的局限性，它一般只针对某个专门软件版本而开发，对于软件演进过程中获得的新版本而言，我们无法确定补丁程序是否也能适用于新版本的程序。然而补丁程序的应用一般都具有特定的目的，例如功能升级、漏洞修补等，新版本的程序中很可能仍然需要补丁程序的应用来完善自身。因而在实际的软件维护过程中工程师往往不得不重新去开发针对该新版本的补丁程序，对人力成本和时间资源造成了许多浪费。

究其缘由，主要在于补丁程序通常会引入软件变更（Software Change），使得软件源代码在应用这些变更后可以实现功能修复、版本升级等目的。使用Diff工具所产生的补丁文件一般会以行为单位引入变更。

然而，软件变更不止会局限于对被修改的某行产生作用，事实上，由于软件代码的耦合性，单行变更就足以将变更带来的影响广泛地传播到软件系统的其他部分中去。因此，软件变更不仅会使软件系统发生结构化的变更，还会产生语义上的变化。例如，对赋值语句的修改可能会影响到后续引用到该变量的条件语句。

因此，如何确定补丁程序对于软件其他版本的适用性就成为了一个较复杂的问题，这主要是由于补丁程序所引入的软件变更和版本升级所引入的软件变更可能是互斥的，或者说是部分互斥的。更准确的来讲，即变更所影响到的的程序语法和语义层面之间的互斥性。

可见，要完全确定补丁程序对其他版本代码的兼容性是一件事实上比较困难的事情，目前就我们所知尚无这方面的相关工作出现。而且这方面的工作比较具有实用价值，能够解决工业界的实际问题，因而本文尝试去解决这样一个软件补丁兼容性检测的问题。

\section{本文所要解决的问题与主要工作}

软件系统总是处于不断演进的过程中的。补丁(Patch)是一种常见的软件系统版本演进的方法，常用于修补漏洞和缺陷、改进性能、升级等。在实际应用中，补丁往往针对某一个特定版本的代码而设计，然而现代软件系统往往更新换代较快，因而面临着将补丁应用于其他版本的代码时可能失效的问题。为了解决这个问题，我们为此提出了进行补丁兼容性分析的想法。

为此，我们考虑这样一个问题，针对某软件系统s，假设已有版本$v_1$和$v_2$，其中补丁$p_1$是针对版本$v_1$而设计，应用后能使其演进到版本$v_3$，问$p_1$是否能够应用于版本$v_{2}$，并保证不会发生冲突。

\subsection{应用场景}
\label {app}

本文中的主要问题在于如何判定一个针对给定程序版本的补丁，它是否能够应用于其他版本，并且与其兼容？为了使读者对这一问题更加清晰，我们可以考虑这样一个应用场景，并且提出相应的前提假设：

\begin{itemize}
	\item 某个团队正在对一软件进行开发工作，该软件已推出一个正式版$v_{1}$，现在正在进行$v_{2}$版本的开发。
	
	\item 该团队使用版本控制系统进行版本控制，使用Github作为代码托管和团队协作工具。
	
	\item 该软件存在一个第三方开发的针对$v_{1}$版本的的补丁p，该补丁可以增强该软件的功能。
	
\end{itemize}

我们希望知道，该补丁p是否能够应用于正式版$v_{2}$，并且补丁p中的变更不仅能够被正确地应用，还不影响软件版本$v_{2}$的功能正确性？

\subsection{问题解读}

事实上，对该问题而言，其答案可以分为多个层面来回答。

从语法角度出发，则该问题主要关注的是在应用过程中是否会造成语法结构上的错误，如果能够将补丁$p_1$成功应用于程序版本$v_2$，则认为该补丁是可以兼容于新版本$v_2$的。语法结构上的错误可能是多种多样的，例如补丁中的要修改的代码不在原位置或已被删除、补丁中要添加的代码已经在该文件中存在等等，不一而足。

从语义角度出发，则单纯的语法兼容并不能够完全解答这个问题。某行修改可能会影响多处源代码，从而导致程序的行为发生变化。因而从语义层面而言，我们需要保证补丁$p_1$对程序版本$v_2$造成的语义影响不会波及到从版本$v_1$演进到$v_2$时所造成的语义变化。也就是说我们需要保证补丁$p_1$和$p_2$之间不会存在冲突——即互斥子集。

语法层面的回答很容易就能给出，现有的版本控制系统等都能在一定程度上给出相应的答案。而对于语义层面的答案来说，就目前所知尚未有这方面的工作。

因而本文将着重从语义层面去尝试解决这个问题。更具体的问题描述可以同样参考章节\ref {define_problem}。


\subsection{主要工作}

目前而言，本文的主要工作包括以下几个部分：
\begin{enumerate}
	\item 提出软件补丁兼容性检测问题。
	\item 提出解决该问题的一套解决方案，包括：
	\begin{itemize}
		\item 补丁应用：将转为某个版本代码而设计的补丁应用于其他版本代码。
		\item 语义影响域分析：分析并获取软件变更对代码的影响域。
		\item 冲突分析：根据得到的影响域，分析是否存在语义冲突。
	\end{itemize}
	\item 根据解决方案给出了具体的工具实现，并在工业界的实际项目上进行了实验。
\end{enumerate}

%\begin{enumerate}
%	\item 补丁应用。
%	\item 语义影响域分析。
%	\item 补丁冲突分析。		
%\end{enumerate}

%可以具体定义如下，其中structure意为程序语法结构，可以采用不同级别的程序语法结构（如statement、basic block等）进行分析，来获得不同粒度的影响范围：
%	\begin{enumerate}
%		\item
%		change(s) = { structure | structure属于p，并且structure 发生了变更}，该集合可以采用程序间差异分析获得。
%		
%		\item
%		impact(s) = {structure| structure属于p，并且structure 受到change(s)的影响}，该集合可以采用变更影响分析获得。
%		
%	\end{enumerate}
%最后得到的impact(s)即为我们所需的变更的语义影响范围。

%所谓的补丁版本迁移工作是指，由于补丁$p_1$本来是适用于程序版本$v_1$的，如果想要适用于程序$v_2$，可能需要进行一定的版本迁移工作。该部分工作可以从语法层面给出兼容性的答案，并为了实现补丁兼容性而进行一定的语法结构修正，主要使用版本控制系统和文本合并工具完成。
%
%所谓的语义域分析工作是指主要采用程序间差异分析、变更影响分析等手段来对界定补丁$p_i$对程序$v_i$所造成的语义影响。在有了补丁$p_1$和$p_2$的语义影响域后，我们对其进行重叠判断，即可找到冲突。该语义影响域分析（Semantic Impacted Area Analysis）过程可以参考章节\ref {sia}中的详细叙述。
%
%而在有了语义影响范围之后，就可以进行冲突分析的工作。通过影响域的重叠判定，我们可以获得两个补丁间的冲突，通过人工分析的辅助，我们可以判定该互斥子集是否存在误报（false positive），并筛选出真正的互斥子集。
%
%我们可以简单的认定如果两个补丁间如果存在真互斥子集，那么他们之间就存在冲突。而实际上，真互斥子集中的一些互斥变更，根据我们的定义他们是互斥的，但在实际应用中他们其实仍然可能是互相兼容的。
%
%如果对真互斥子集进行人工的冲突分析，可以将这些情况进一步剔除。
%
%可见，我们给出的冲突定义是比实际冲突更加严格的定义，可能会造成一定的过高估计（over-estimate）。在第\ref {exp}章的实验中我们会给出具体的介绍。


\section{本文组织结构}

本文主要包括六个章节，第一章是绪论，介绍本文的研究背景和主要工作；第二章主要介绍与本文所述内容相关的国内外的工作；第三章主要介绍了补丁兼容性分析的具体方法；第四章主要介绍了如何将各阶段的不同分析方法进行整合，形成具体的流程；第五章介绍了实验过程和结果；第六章主要对本文的工作进行了总结，并提出了进一步的工作方向。

%\section{本章小结}
%本章中主要提出了如何进行软件补丁兼容性检测的问题，并介绍了其实际意义。其次介绍了本文中为了解决该问题而做出的主要工作，最后给出了本文的组织结构。

